import React from "react";
import update from "immutability-helper";

import { StoreContext } from "./";

function withData(actions) {
  function enhance(WrappedComponent) {
    class Enhanced extends React.Component {
      constructor(props, context) {
        super(props, context);
        // Set all queries to { loading: true, applyParams: fn(), refetch: fn() }
        const data = {};
        const appliedParams = {};
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => {
          data[actionName] = {
            loading: true,
            applyParams: params => this.applyParams(actionName, params),
            clearParams: () => this.clearParams(actionName),
            refetch: () => this.getData(actionName, { noCache: true }),
            optimisticUpdate: optimisticData =>
              this.onNext(actionName, optimisticData)
          };
          appliedParams[actionName] = {};
        });
        this.state = {
          data, // Data object to send to child
          appliedParams, // Filters, pages, sorts, etc (matches the structure of `data`)
          polls: [], // Ids for polling - stop on unmount
          observeIds: [] // Ids for store.js observables - unobserve on unmount
        };
      }

      // REACT LIFECYCLE METHODS

      componentDidMount() {
        this.fetchAll();
      }

      componentDidUpdate(prevProps, prevState) {
        // This code exists because the setState callback would not work for applyParams below
        // May be related to https://github.com/facebook/react/issues/1740
        const hasNewParams =
          prevState.appliedParams !== this.state.appliedParams;
        if (hasNewParams) {
          const actionNames = Object.keys(this.state.appliedParams);
          actionNames.forEach(actionName => {
            if (
              prevState.appliedParams[actionName] !==
              this.state.appliedParams[actionName]
            ) {
              this.getData(actionName);
            }
          });
        }
      }

      componentWillUnmount() {
        const { observeIds, polls } = this.state;
        const { store } = this.context;
        observeIds.forEach(cacheKey => {
          store.unobserveData(cacheKey);
        });
        polls.forEach(poll => {
          clearInterval(poll);
        });
      }

      // CUSTOM METHODS

      // Set data[actionName] from { loading: false } + the result of the request
      onNext = (actionName, data) => {
        this.setState(prevState =>
          update(prevState, {
            data: {
              [actionName]: { $merge: { loading: false, ...data } }
            }
          })
        );
      };

      // Set data[actionName] from { loading: false } + the { error } generated by Axios
      onError = (actionName, error) => {
        const isAxiosError = Object.keys(error).includes("request"); // crude, but works
        if (isAxiosError) {
          this.setState(prevState =>
            update(prevState, {
              data: {
                [actionName]: { $merge: { loading: false, error } }
              }
            })
          );
        } else {
          throw error;
        }
      };

      getData = (actionName, options = {}) => {
        const { store } = this.context;
        const { noCache, ...overrides } = options;
        const appliedParams = this.state.appliedParams[actionName];
        let action;
        let childOptions = {};

        if (Array.isArray(actions[actionName])) {
          [action] = actions[actionName];
          childOptions = actions[actionName][1] || {};
        } else {
          action = actions[actionName];
        }

        store
          .observeData(
            actionName,
            () => action({ ...appliedParams, ...this.props, ...overrides }),
            data => this.onNext(actionName, data),
            error => this.onError(actionName, error),
            { noCache, ...childOptions }
          )
          .then(({ observableId, poll }) => {
            if (poll) {
              this.setState(prevState =>
                update(prevState, {
                  observeIds: { $push: [observableId] },
                  polls: { $push: [poll] }
                })
              );
            } else {
              this.setState(prevState =>
                update(prevState, {
                  observeIds: { $push: [observableId] }
                })
              );
            }
          });
      };

      fetchAll = () => {
        // Request data for each query
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => this.getData(actionName));
      };

      applyParams = (actionName, params) => {
        this.setState(prevState =>
          update(prevState, {
            data: { [actionName]: { loading: { $set: true } } },
            appliedParams: { [actionName]: { $merge: params } }
          })
        );
      };

      clearParams = actionName => {
        this.setState(prevState =>
          update(prevState, {
            appliedParams: { [actionName]: { $set: {} } }
          })
        );
      };

      render() {
        return <WrappedComponent data={this.state.data} {...this.props} />;
      }
    }

    Enhanced.contextType = StoreContext;

    return Enhanced;
  }

  return enhance;
}

export default withData;
