import React from "react";
import update from "immutability-helper";
import { observeData, unobserveData } from "./cache";

function withData(actions) {
  function enhance(WrappedComponent) {
    return class extends React.Component {
      constructor(props) {
        super(props);
        // Set all queries to { loading: true, refetch: getData() }
        const data = {};
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => {
          data[actionName] = {
            loading: true,
            refetch: () => this.getData(actionName, { noCache: true })
          };
        });
        this.state = {
          data,
          polls: [],
          observeIds: []
        };
      }

      goToPage = (actionName, page) => {
        this.setState(
          prevState =>
            update(prevState, {
              data: { [actionName]: { loading: { $set: true } } }
            }),
          this.getData(actionName, { page })
        );
      };

      // Set data[actionName] from { loading: false } + the result of the request
      onNext = (actionName, data) => {
        const loading = false;
        const goToPage = page => this.goToPage(actionName, page);
        this.setState(prevState =>
          update(prevState, {
            data: {
              [actionName]: { $merge: { loading, goToPage, ...data } }
            }
          })
        );
      };

      // Set data[actionName] from { loading: false } + the { error } generated by Axios
      onError = (actionName, error) => {
        const loading = false;
        const isAxiosError = Object.keys(error).includes("request"); // crude, but works
        if (isAxiosError) {
          this.setState(prevState =>
            update(prevState, {
              data: {
                [actionName]: { $merge: { loading, error } }
              }
            })
          );
        } else {
          throw error;
        }
      };

      getData = (actionName, options = {}) => {
        const { noCache, ...overrides } = options;
        let action;
        let childOptions = {};

        if (Array.isArray(actions[actionName])) {
          action = actions[actionName][0];
          childOptions = actions[actionName][1] || {};
        } else {
          action = actions[actionName];
        }

        observeData(
          actionName,
          () => action({ ...this.props, ...overrides }),
          data => this.onNext(actionName, data),
          error => this.onError(actionName, error),
          { noCache, ...childOptions }
        ).then(result => {
          if (Array.isArray(result)) {
            const [observeId, poll] = result;
            this.setState(prevState =>
              update(prevState, {
                observeIds: { $push: [observeId] },
                polls: { $push: [poll] }
              })
            );
          } else {
            const observeId = result;
            this.setState(prevState =>
              update(prevState, {
                observeIds: { $push: [observeId] }
              })
            );
          }
        });
      };

      componentDidMount() {
        // Request data for each query
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => this.getData(actionName));
      }

      componentWillUnmount() {
        const { observeIds, polls } = this.state;
        observeIds.forEach(cacheKey => {
          unobserveData(cacheKey);
        });
        polls.forEach(poll => {
          clearInterval(poll);
        });
      }

      render() {
        return <WrappedComponent data={this.state.data} {...this.props} />;
      }
    };
  }

  return enhance;
}

export default withData;
