import React from "react";
import update from "immutability-helper";
import { observeData, unobserveData } from "./cache";

function withData(actions) {
  function enhance(WrappedComponent) {
    return class extends React.Component {
      constructor(props) {
        super(props);
        // Set all queries to { loading: true, applyParams: fn(), refetch: fn() }
        const data = {};
        const appliedParams = {};
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => {
          data[actionName] = {
            loading: true,
            applyParams: params => this.applyParams(actionName, params),
            refetch: () => this.getData(actionName, { noCache: true })
          };
          appliedParams[actionName] = {};
        });
        this.state = {
          data, // Data object to send to child
          appliedParams, // Filters, pages, sorts, etc (matches the structure of `data`)
          polls: [], // Ids for polling - stop on unmount
          observeIds: [] // Ids for store.js observables - unobserve on unmount
        };
      }

      applyParams = (actionName, params) => {
        this.setState(
          prevState => {
            update(prevState, {
              data: { [actionName]: { loading: { $set: true } } },
              appliedParams: { [actionName]: { $merge: params } }
            });
          },
          () => this.getData(actionName)
        );
      };

      // Set data[actionName] from { loading: false } + the result of the request
      onNext = (actionName, data) => {
        this.setState(prevState => {
          update(prevState, {
            data: {
              [actionName]: { $merge: { loading: false, ...data } }
            }
          });
        });
      };

      // Set data[actionName] from { loading: false } + the { error } generated by Axios
      onError = (actionName, error) => {
        const isAxiosError = Object.keys(error).includes("request"); // crude, but works
        if (isAxiosError) {
          this.setState(prevState => {
            update(prevState, {
              data: {
                [actionName]: { $merge: { error, loading: false } }
              }
            });
          });
        } else {
          throw error;
        }
      };

      getData = (actionName, options = {}) => {
        const { noCache, ...overrides } = options;
        const appliedParams = this.state.appliedParams[actionName];
        let action;
        let childOptions = {};

        if (Array.isArray(actions[actionName])) {
          action = actions[actionName][0];
          childOptions = actions[actionName][1] || {};
        } else {
          action = actions[actionName];
        }

        observeData(
          actionName,
          () => action({ ...appliedParams, ...this.props, ...overrides }),
          data => this.onNext(actionName, data),
          error => this.onError(actionName, error),
          { noCache, ...childOptions }
        ).then(result => {
          if (Array.isArray(result)) {
            const [observeId, poll] = result;
            this.setState(prevState =>
              update(prevState, {
                observeIds: { $push: [observeId] },
                polls: { $push: [poll] }
              })
            );
          } else {
            const observeId = result;
            this.setState(prevState =>
              update(prevState, {
                observeIds: { $push: [observeId] }
              })
            );
          }
        });
      };

      componentDidMount() {
        // Request data for each query
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => this.getData(actionName));
      }

      componentWillUnmount() {
        const { observeIds, polls } = this.state;
        observeIds.forEach(cacheKey => {
          unobserveData(cacheKey);
        });
        polls.forEach(poll => {
          clearInterval(poll);
        });
      }

      render() {
        return <WrappedComponent data={this.state.data} {...this.props} />;
      }
    };
  }

  return enhance;
}

export default withData;
