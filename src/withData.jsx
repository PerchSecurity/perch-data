import React from "react";
import update from "immutability-helper";
import { observeData, unobserveData } from "./cache";

function withData(actions) {
  function enhance(WrappedComponent) {
    return class extends React.Component {
      constructor(props) {
        super(props);

        // Set all queries to { loading: true, refetch: getData() }
        const data = {};
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => {
          data[actionName] = {
            loading: true,
            refetch: () => this.getData(actionName, { nocache: true })
          };
        });
        this.state = { obeserveIds: [], data };
      }

      goToPage = (actionName, page) => {
        this.setState(
          prevState =>
            update(prevState, {
              data: { [actionName]: { loading: { $set: true } } }
            }),
          this.getData(actionName, { page })
        );
      };

      // Set data[actionName] from { loading: false } + the result of the request
      onNext = (actionName, data) => {
        const loading = false;
        const goToPage = page => this.goToPage(actionName, page);
        this.setState(prevState =>
          update(prevState, {
            data: {
              [actionName]: { $merge: { loading, goToPage, ...data } }
            }
          })
        );
      };

      // Set data[actionName] from { loading: false } + the { error } generated by Axios
      onError = (actionName, error) => {
        const loading = false;
        const isAxiosError = Object.keys(error).includes("request"); // crude, but works
        if (isAxiosError) {
          this.setState(prevState =>
            update(prevState, {
              data: {
                [actionName]: { $merge: { loading, error } }
              }
            })
          );
        } else {
          throw error;
        }
      };

      getData = (actionName, options) => {
        const mergedOptions = Object.assign({}, this.props, options);
        observeData(
          actionName,
          () => actions[actionName](mergedOptions),
          data => this.onNext(actionName, data),
          error => this.onError(actionName, error),
          mergedOptions.nocache
        ).then(obeserveId => {
          this.setState(prevState =>
            update(prevState, {
              obeserveIds: { $push: [obeserveId] }
            })
          );
        });
      };

      componentDidMount() {
        // Request data for each query
        const actionNames = Object.keys(actions);
        actionNames.forEach(actionName => this.getData(actionName));
      }

      componentWillUnmount() {
        const { obeserveIds } = this.state;
        obeserveIds.forEach(cacheKey => {
          unobserveData(cacheKey);
        });
      }

      render() {
        return <WrappedComponent data={this.state.data} {...this.props} />;
      }
    };
  }

  return enhance;
}

export default withData;
